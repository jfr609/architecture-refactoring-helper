// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Repository.Models;

#nullable disable

namespace Repository.Migrations
{
    [DbContext(typeof(RefactoringApproachContext))]
    partial class RefactoringApproachContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "6.0.1");

            modelBuilder.Entity("AnalysisTypeApproachProcess", b =>
                {
                    b.Property<string>("AnalysisTypesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.HasKey("AnalysisTypesName", "ApproachProcessesApproachProcessId");

                    b.HasIndex("ApproachProcessesApproachProcessId");

                    b.ToTable("JoinTable.Approach.Process.AnalysisType", (string)null);
                });

            modelBuilder.Entity("ApproachOutputRefactoringApproach", b =>
                {
                    b.Property<int>("ApproachOutputsApproachOutputId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachOutputsApproachOutputId", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Output", (string)null);
                });

            modelBuilder.Entity("ApproachProcessAtomarUnit", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("AtomarUnitsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "AtomarUnitsName");

                    b.HasIndex("AtomarUnitsName");

                    b.ToTable("JoinTable.Approach.Process.AtomarUnit", (string)null);
                });

            modelBuilder.Entity("ApproachProcessAutomationLevel", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("AutomationLevelsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "AutomationLevelsName");

                    b.HasIndex("AutomationLevelsName");

                    b.ToTable("JoinTable.Approach.Process.AutomationLevel", (string)null);
                });

            modelBuilder.Entity("ApproachProcessDirection", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("DirectionsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "DirectionsName");

                    b.HasIndex("DirectionsName");

                    b.ToTable("JoinTable.Approach.Process.Direction", (string)null);
                });

            modelBuilder.Entity("ApproachProcessProcessStrategy", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ProcessStrategiesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "ProcessStrategiesName");

                    b.HasIndex("ProcessStrategiesName");

                    b.ToTable("JoinTable.Approach.Process.Strategy", (string)null);
                });

            modelBuilder.Entity("ApproachProcessQuality", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("QualitiesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "QualitiesName");

                    b.HasIndex("QualitiesName");

                    b.ToTable("JoinTable.Approach.Process.Quality", (string)null);
                });

            modelBuilder.Entity("ApproachProcessQualitySublevel", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("QualitySublevelsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "QualitySublevelsName");

                    b.HasIndex("QualitySublevelsName");

                    b.ToTable("JoinTable.Approach.Process.QualitySublevel", (string)null);
                });

            modelBuilder.Entity("ApproachProcessTechnique", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("TechniquesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "TechniquesName");

                    b.HasIndex("TechniquesName");

                    b.ToTable("JoinTable.Approach.Process.Technique", (string)null);
                });

            modelBuilder.Entity("ApproachUsabilityTool", b =>
                {
                    b.Property<int>("ApproachUsabilitiesApproachUsabilityId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ToolsToolId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachUsabilitiesApproachUsabilityId", "ToolsToolId");

                    b.HasIndex("ToolsToolId");

                    b.ToTable("JoinTable.Approach.Usability.Tool", (string)null);
                });

            modelBuilder.Entity("DomainArtifactInputRefactoringApproach", b =>
                {
                    b.Property<string>("DomainArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("DomainArtifactInputsName", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Input.DomainArtifact", (string)null);
                });

            modelBuilder.Entity("ExecutableInputRefactoringApproach", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ExecutableInputsName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ExecutableInputsLanguage")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "ExecutableInputsName", "ExecutableInputsLanguage");

                    b.HasIndex("ExecutableInputsName", "ExecutableInputsLanguage");

                    b.ToTable("JoinTable.Approach.Input.Executable", (string)null);
                });

            modelBuilder.Entity("ModelArtifactInputRefactoringApproach", b =>
                {
                    b.Property<string>("ModelArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ModelArtifactInputsName", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Input.ModelArtifact", (string)null);
                });

            modelBuilder.Entity("QualityScenario", b =>
                {
                    b.Property<string>("QualitiesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ScenariosScenarioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("QualitiesName", "ScenariosScenarioId");

                    b.HasIndex("ScenariosScenarioId");

                    b.ToTable("QualityScenario");
                });

            modelBuilder.Entity("QualitySublevelScenario", b =>
                {
                    b.Property<string>("QualitySublevelsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ScenariosScenarioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("QualitySublevelsName", "ScenariosScenarioId");

                    b.HasIndex("ScenariosScenarioId");

                    b.ToTable("QualitySublevelScenario");
                });

            modelBuilder.Entity("RefactoringApproachRepresentation", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("RepresentationOutputsName")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "RepresentationOutputsName");

                    b.HasIndex("RepresentationOutputsName");

                    b.ToTable("JoinTable.Approach.Output.Representation", (string)null);
                });

            modelBuilder.Entity("RefactoringApproachRuntimeArtifactInput", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("RuntimeArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "RuntimeArtifactInputsName");

                    b.HasIndex("RuntimeArtifactInputsName");

                    b.ToTable("JoinTable.Approach.Input.RuntimeArtifact", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.AccuracyPrecision", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.AccuracyPrecision", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "High",
                            Description = "Estimates the accuracy/precision of the approach as high."
                        },
                        new
                        {
                            Name = "Medium",
                            Description = "Estimates the accuracy/precision of the approach as medium."
                        },
                        new
                        {
                            Name = "Low",
                            Description = "Estimates the accuracy/precision of the approach as low."
                        },
                        new
                        {
                            Name = "Not available",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AnalysisType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AnalysisType", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Static",
                            Description = "Static analysis is performed without executing an application. Commonly it is performed on source code, but can also involve interface descriptions or version control system data. The analysis involves, e.g., dependencies between classes, class attributes, or method calls. These dependencies indicate strongly connected classes that can be clustered for a single service."
                        },
                        new
                        {
                            Name = "Dynamic",
                            Description = "Dynamic analysis is performed by examining the application at run time. Dependencies between software elements (e.g., class instantiations and accesses, function calls, relationships between database tables, etc.) are collected. To this end, a set of use cases or scenarios has to be performed that reflect the system's functionalities."
                        },
                        new
                        {
                            Name = "Lexical",
                            Description = "Lexical analysis techniques suppose that textual similarities between identifiers of classes, methods, or interfaces help in the service identification process."
                        },
                        new
                        {
                            Name = "Historic",
                            Description = "Historic analysis techniques leverage, e.g, the history data of a version control system to identify cohesive source code structures based on authors, change frequency, and correlation of changes."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachOutput", b =>
                {
                    b.Property<int>("ApproachOutputId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ArchitectureName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("ServiceTypeName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachOutputId");

                    b.HasIndex("ArchitectureName");

                    b.HasIndex("ServiceTypeName");

                    b.ToTable("Approach.Output");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachProcess", b =>
                {
                    b.Property<int>("ApproachProcessId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachProcessId");

                    b.ToTable("Approach.Process");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachSource", b =>
                {
                    b.Property<int>("ApproachSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Authors")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Link")
                        .HasColumnType("TEXT");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<int>("Year")
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachSourceId");

                    b.ToTable("Approach.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.Property<int>("ApproachUsabilityId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("AccuracyPrecisionName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<bool?>("NoToolSupport")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ResultsQualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ToolSupportName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ValidationMethodName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachUsabilityId");

                    b.HasIndex("AccuracyPrecisionName");

                    b.HasIndex("ResultsQualityName");

                    b.HasIndex("ToolSupportName");

                    b.HasIndex("ValidationMethodName");

                    b.ToTable("Approach.Usability");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesign", b =>
                {
                    b.Property<int>("ArchitecturalDesignId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ArchitecturalDesignSourceId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("Category")
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ArchitecturalDesignId");

                    b.HasIndex("ApproachProcessId")
                        .IsUnique();

                    b.HasIndex("ArchitecturalDesignSourceId")
                        .IsUnique();

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.ToTable("ArchitecturalDesign");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesignSource", b =>
                {
                    b.Property<int>("ArchitecturalDesignSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Links")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Source")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ArchitecturalDesignSourceId");

                    b.ToTable("ArchitecturalDesign.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.Architecture", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.Architecture", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Services",
                            Description = ""
                        },
                        new
                        {
                            Name = "Microservices",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AtomarUnit", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AtomarUnit", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Function",
                            Description = "A function, method, or procedure of the source code represents the smallest unit that the approach can treat in the course of a decomposition."
                        },
                        new
                        {
                            Name = "Functionality",
                            Description = "A functionality of the application, e.g., a requirement or use case, represents the smallest unit that the approach can treat in the course of a decomposition."
                        },
                        new
                        {
                            Name = "Business Capability",
                            Description = "A business capability represents the smallest unit that the approach can treat in the course of a decomposition."
                        },
                        new
                        {
                            Name = "Entity",
                            Description = "An entity, commonly in the context of data or databases, represents the smallest unit that the approach can treat in the course of a decomposition."
                        },
                        new
                        {
                            Name = "Interface",
                            Description = "An interface of the application, commonly exposed functionality through an API, represents the smallest unit that the approach can treat in the course of a decomposition."
                        },
                        new
                        {
                            Name = "Other",
                            Description = "The approach defines no or no specific smallest unit used for the decomposition."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AutomationLevel", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AutomationLevel", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Automatic",
                            Description = "An automatic approach needs only minimal human intervention in the refactoring process."
                        },
                        new
                        {
                            Name = "Semi-automatic",
                            Description = "An semi-automatic approach needs human expertise in the refactoring process, which is partly automated."
                        },
                        new
                        {
                            Name = "Manual",
                            Description = "A manual approach relies entirely on human expertise."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.CalculationMetric", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualitySublevelName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.HasIndex("QualitySublevelName");

                    b.ToTable("Approach.Process.CalculationMetric");
                });

            modelBuilder.Entity("Repository.Models.Database.Direction", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Direction", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Bottom-up",
                            Description = "A bottom-up approach works on low-level artifacts like source code or databases. It thereby maximizes code reuse and minimizes changes."
                        },
                        new
                        {
                            Name = "Top-down",
                            Description = "A top-down approach works on high-level artifacts, e.g., requirements or use cases that characterize the system's functionalities."
                        },
                        new
                        {
                            Name = "Mixed",
                            Description = "A mixed or hybrid approach combines a top-down and a bottom-up process for identification of services."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.DomainArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.DomainArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Ontology",
                            Description = "An ontology represents a structured taxonomy that reflects the semantics of a domain, e.g., through meta-data or domain elements."
                        },
                        new
                        {
                            Name = "Human expertise",
                            Description = "Substantial domain knowledge and technical expertise are required for applying the approach."
                        },
                        new
                        {
                            Name = "Documentation",
                            Description = "Software documentation includes specifications, textual descriptions, or diagrams that document the application at different levels of abstraction."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ExecutableInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Language")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name", "Language");

                    b.ToTable("Approach.Input.Executable", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Source code",
                            Language = "No specification",
                            Description = "Source code written in an arbitrary programming language is required as input."
                        },
                        new
                        {
                            Name = "Database file",
                            Language = "No specification",
                            Description = "The database schema or contents are required as input."
                        },
                        new
                        {
                            Name = "Test cases",
                            Language = "No specification",
                            Description = "Test cases of the application are required as input."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ModelArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.ModelArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Business process model",
                            Description = "Business Process Models (BPMs) are data-driven visual representations of business processes. They contain sets of activities and tasks that accomplish an organizational goal."
                        },
                        new
                        {
                            Name = "Use case model",
                            Description = "Use case diagrams are behavioral diagrams and visualize the externally visible interaction of actors with the application. They relate system and actors to each other through use cases."
                        },
                        new
                        {
                            Name = "Activity diagram",
                            Description = "Activity diagrams visually present a series of actions or a control flow in an application."
                        },
                        new
                        {
                            Name = "Data flow diagram",
                            Description = "Data Flow Diagrams (DFDs) are graphical representations of functional dependencies between business functions or processes, based on the analysis of data flows."
                        },
                        new
                        {
                            Name = "State machine diagram",
                            Description = "State Machine Diagrams (SMDs) shows a dynamic view of a system and describe the states that entities can enter during their lifetimes."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Objectives", b =>
                {
                    b.Property<int>("ObjectivesId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ObjectivesGoalType")
                        .HasColumnType("TEXT");

                    b.Property<string>("ObjectivesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ObjectivesId");

                    b.ToTable("Objectives");
                });

            modelBuilder.Entity("Repository.Models.Database.ProcessStrategy", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Strategy", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Greenfield",
                            Description = "The Greenfield strategy aims for building an entirely new application or system without restrictions or dependencies on the legacy application."
                        },
                        new
                        {
                            Name = "Rewrite / Rebuild",
                            Description = "Rewriting or rebuilding an application eases the introduction of new technologies. Individual services can be implemented using, e.g., the most suitable programming language or database technology. They can resolve current technical limitations and thereby improve several qualities of the application."
                        },
                        new
                        {
                            Name = "Refactor",
                            Description = "The existing monolithic code base is split up adequately into smaller parts, eventually forming several microservices. In the process of a refactoring, the currently employed technologies like programming languages, libraries, or packages can be retained. Moving to new technologies is not a necessity and thus reduces the overall cost and effort, allowing to shorten the timeframe for the entire migration process."
                        },
                        new
                        {
                            Name = "Strangler",
                            Description = "The Strangler pattern suggests to iteratively replace parts or components of the system with new services in a resource-efficient and targeted manner. Existing functionalities will be implemented as services that are then attached to the existing system, while at the same time, this functionality in the legacy system is disabled. The process is completed when the newly emerged microservices application replaces the legacy system entirely."
                        },
                        new
                        {
                            Name = "Continuous Evolution",
                            Description = "The Continuous Evolution strategy aims at minimizing the efforts and maintaining the system in its current state as far as possible. Compared to the Refactor strategy, changes can be done in a more targeted manner, e.g., combined with the implementation of new features, or based on certain qualities that should be improved."
                        },
                        new
                        {
                            Name = "Extension",
                            Description = "This strategy aims for substantially extending the application's functionality in the course of a migration to microservices and is often combined with one of the other process strategies."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ProjectDescription", b =>
                {
                    b.Property<int>("ProjectDescriptionId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Architecturepattern")
                        .HasColumnType("TEXT");

                    b.Property<string>("Creation_date")
                        .HasColumnType("TEXT");

                    b.Property<string>("Data_Persistence")
                        .HasColumnType("TEXT");

                    b.Property<string>("Designdiagrams")
                        .HasColumnType("TEXT");

                    b.Property<string>("Functionality")
                        .HasColumnType("TEXT");

                    b.Property<string>("Hosting_model")
                        .HasColumnType("TEXT");

                    b.Property<string>("Languages")
                        .HasColumnType("TEXT");

                    b.Property<int?>("Number_of_Developers")
                        .HasColumnType("INTEGER");

                    b.Property<int?>("Number_of_Teams")
                        .HasColumnType("INTEGER");

                    b.Property<string>("Ownership")
                        .HasColumnType("TEXT");

                    b.Property<string>("Processmodel")
                        .HasColumnType("TEXT");

                    b.Property<string>("Purpose")
                        .HasColumnType("TEXT");

                    b.Property<string>("Systemname")
                        .HasColumnType("TEXT");

                    b.Property<int?>("Systemsize_LOC")
                        .HasColumnType("INTEGER");

                    b.HasKey("ProjectDescriptionId");

                    b.ToTable("ProjectDescription", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualitySublevelName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.HasIndex("QualitySublevelName");

                    b.ToTable("Approach.Process.Quality", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Reliability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Compatibility",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Security",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Performance",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Scalability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Portability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Independence",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Maintainability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Business",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Cohesion",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Coupling",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Granularity",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Isolation",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Autonomy",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Technology Heterogeneity",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Complexity",
                            Category = "SystemProperty",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.ToTable("Approach.Process.QualitySublevel", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Availability",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Fault Tolerance",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Recoverability",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Interoperability",
                            QualityName = "Compatibility"
                        },
                        new
                        {
                            Name = "Co-Existence",
                            QualityName = "Compatibility"
                        },
                        new
                        {
                            Name = "Confidentiality",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Accountability",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Authenticity",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Integrity",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Time Behavior",
                            QualityName = "Performance"
                        },
                        new
                        {
                            Name = "Resource Utilization",
                            QualityName = "Performance"
                        },
                        new
                        {
                            Name = "Installability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Adaptability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Replaceability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Deployability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Agility",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Modifiability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Modularity",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Reusability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Testability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Analysability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Monitorability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Manageability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Understandability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Execution Cost",
                            QualityName = "Business"
                        },
                        new
                        {
                            Name = "Organizational Alignment",
                            QualityName = "Business"
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.RefactoringApproach", b =>
                {
                    b.Property<int>("RefactoringApproachId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachSourceId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachUsabilityId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachId");

                    b.HasIndex("ApproachProcessId")
                        .IsUnique();

                    b.HasIndex("ApproachSourceId")
                        .IsUnique();

                    b.HasIndex("ApproachUsabilityId")
                        .IsUnique();

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.ToTable("Approaches");
                });

            modelBuilder.Entity("Repository.Models.Database.Representation", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.Representation", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Source code",
                            Description = "The approach generates source code for individual microservices or a skeleton for their implementation."
                        },
                        new
                        {
                            Name = "List of services",
                            Description = "The approach generates a list of services that typically contains clustered elements of the atomic unit."
                        },
                        new
                        {
                            Name = "Splitting recommendations",
                            Description = "The approach produces splitting recommendations or creates potential parameterizable service cuts."
                        },
                        new
                        {
                            Name = "Guideline / Workflow",
                            Description = "The approach does not produce tangible output artifacts, but rather serves as guideline or workflow in the decomposition process. It typically requires a high degree of human expertise and offers a low degree of automation."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ResultsQuality", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ResultsQuality", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "High",
                            Description = "Estimates the quality of the identified candidate service(s) as high."
                        },
                        new
                        {
                            Name = "Medium",
                            Description = "Estimates the quality of the identified candidate service(s) as medium."
                        },
                        new
                        {
                            Name = "Low",
                            Description = "Estimates the quality of the identified candidate service(s) as low."
                        },
                        new
                        {
                            Name = "Not available",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.RuntimeArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.RuntimeArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Log traces",
                            Description = "Execution traces of the monolithic application, that reflect the dynamic behavior, are required as input."
                        },
                        new
                        {
                            Name = "User-Application interactions",
                            Description = "User-interface interactions that capture the actions a user performs when using certain functionalities are required as input."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Scenario", b =>
                {
                    b.Property<int>("ScenarioId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("Difficulty")
                        .HasColumnType("TEXT");

                    b.Property<string>("Explanation")
                        .HasColumnType("TEXT");

                    b.Property<string>("ImplementedPattern")
                        .HasColumnType("TEXT");

                    b.Property<string>("Importance")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("PreferredPattern")
                        .HasColumnType("TEXT");

                    b.HasKey("ScenarioId");

                    b.ToTable(".Scenario", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.ServiceType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.ServiceType", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Business services",
                            Description = "Business services correspond to business processes or use cases and are services used by users. Examples of business services include flight booking services."
                        },
                        new
                        {
                            Name = "Enterprise services",
                            Description = "Enterprise services are of finer granularity than business services. They implement generic business functionalities that can be reused across different applications. Examples of enterprise services include \"online payment\" and \"tax calculation\"."
                        },
                        new
                        {
                            Name = "Application services",
                            Description = "Application services provide functionalities specific to one application. They exist to support reuse within one application. Examples of application-task services include quoting requests."
                        },
                        new
                        {
                            Name = "Entity services",
                            Description = "Entity services provide access to and the management of the persistent data of legacy software systems. They support actions on data (CRUD) and may have side-effects like modification of shared data. Examples of entity services include management services for clients, and bank accounts."
                        },
                        new
                        {
                            Name = "Utility services",
                            Description = "Utility services do not directly support business services but provide some cross-cutting functionalities required by domain-specific services. Examples of typical utility services include notification, logging, and authentication."
                        },
                        new
                        {
                            Name = "Infrastructure services",
                            Description = "Infrastructure services allow users to deploy and run service oriented architecture systems. They include services for communication routing, protocol conversion, message processing and transformation. Examples of infrastructure services include publish–subscribe, message queues, and enterprise service buses (ESBs)."
                        },
                        new
                        {
                            Name = "No specification",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.StrategicGoals", b =>
                {
                    b.Property<int>("StrategicGoalsId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Method")
                        .HasColumnType("TEXT");

                    b.Property<string>("Owner")
                        .HasColumnType("TEXT");

                    b.Property<string>("Participants")
                        .HasColumnType("TEXT");

                    b.HasKey("StrategicGoalsId");

                    b.ToTable("StrategicGoals", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.Technique", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Technique", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Wrapping / Black Box",
                            Description = "A Wrapping / Black Box technique is characterized by leaving an existing implementation unchanged, but wraps it by an additional service layer that exposes only the needed functionality."
                        },
                        new
                        {
                            Name = "Genetic algorithm",
                            Description = "Genetic algorithms are defined as a meta-heuristic for solving optimization problems that is based on 'natural selection' that relies on the calculation of a fitness function to reach an optimal (or near-optimal) solution. However, the yielded optimization and service cut may not necessarily be architecturally relevant."
                        },
                        new
                        {
                            Name = "Clustering",
                            Description = "Clustering is a technique of classifying and partitioning elements into clusters that share common properties. These clusters are built based on the internal homogeneity of their elements and the external separation between them. In the context of generating highly cohesive and loosely coupled services, clustering is an essential technique next to rule-based methods."
                        },
                        new
                        {
                            Name = "Custom heuristics",
                            Description = "Custom heuristics comprise techniques that have been specifically developed for the decomposition task. They do not clearly identify as one of the other mentioned techniques."
                        },
                        new
                        {
                            Name = "General guidelines",
                            Description = "No specific technique is used. The approaches usually describes the decomposition on a higher level of abstraction by proposing best practices, lessons learned, or recommendations for service identification."
                        },
                        new
                        {
                            Name = "Domain-Driven Design",
                            Description = "Domain-Driven Design (DDD) is a popular manual technique in the context of microservices identification. Its complexity and involvement of domain expertise makes an automation difficult."
                        },
                        new
                        {
                            Name = "Data-flow driven",
                            Description = "Data-Flow driven techniques inspect the flow and processing of data throughout the application, e.g., by means of data flow diagrams."
                        },
                        new
                        {
                            Name = "Graph-based",
                            Description = "Graph-based techniques are common in the context of static code analysis, e.g., to represent source code at a higher level of abstraction."
                        },
                        new
                        {
                            Name = "Scenario analysis",
                            Description = "Scenario analysis is usually associated with a top-down direction and the utilization of, e.g., use-case models as input, but can also be used in conjunction with dynamic analysis techniques."
                        },
                        new
                        {
                            Name = "Execution-trace modeling",
                            Description = "Execution-trace modeling reflects the application's runtime behavior. It can require the collection of logs or execution traces, which sometimes requires instrumenting the application and/or performing certain scenarios or user interactions."
                        },
                        new
                        {
                            Name = "Performance modeling",
                            Description = "Performance modeling techniques aim to direct the decomposition of the applications by taking into account performance and scalability aspects."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Tool", b =>
                {
                    b.Property<int>("ToolId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<int>("ToolSourceId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ToolId");

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.HasIndex("ToolSourceId")
                        .IsUnique();

                    b.ToTable("Tools");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSource", b =>
                {
                    b.Property<int>("ToolSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("Link")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ToolSourceId");

                    b.ToTable("Tool.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSupport", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ToolSupport", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Industry ready",
                            Description = "The tool has been applied to production environments in industry."
                        },
                        new
                        {
                            Name = "Open source",
                            Description = "The tool is developed as open source software."
                        },
                        new
                        {
                            Name = "Prototype",
                            Description = "The tool is in a prototype state which can entail several limitations, such as no evaluation, limited functionality, or no support."
                        },
                        new
                        {
                            Name = "No tool support",
                            Description = "The approach offers no tool support."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ToolType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Tool.Type", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Static Analysis",
                            Description = "The tool performs a static analysis."
                        },
                        new
                        {
                            Name = "Dynamic Analysis",
                            Description = "The tool performs a dynamic analysis."
                        },
                        new
                        {
                            Name = "Decomposition",
                            Description = "The tool performs a decomposition into microservices."
                        },
                        new
                        {
                            Name = "Other",
                            Description = "The tool serves another purpose (see tool description)."
                        },
                        new
                        {
                            Name = "Open Source",
                            Description = "The tool is developed as open source software."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ValidationMethod", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ValidationMethod", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Experiment",
                            Description = "The approach was applied to and tested on one or more (small) experimental applications."
                        },
                        new
                        {
                            Name = "Industry",
                            Description = "The approach was applied to and tested on a industry-scale system."
                        },
                        new
                        {
                            Name = "Case study",
                            Description = "The approach was applied in a real production environment which typically involves external participants."
                        },
                        new
                        {
                            Name = "No validation",
                            Description = "The approach documents no validation."
                        });
                });

            modelBuilder.Entity("ToolToolType", b =>
                {
                    b.Property<string>("ToolTypesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ToolsToolId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ToolTypesName", "ToolsToolId");

                    b.HasIndex("ToolsToolId");

                    b.ToTable("JoinTable.Tool.Type", (string)null);
                });

            modelBuilder.Entity("AnalysisTypeApproachProcess", b =>
                {
                    b.HasOne("Repository.Models.Database.AnalysisType", null)
                        .WithMany()
                        .HasForeignKey("AnalysisTypesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachOutputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachOutput", null)
                        .WithMany()
                        .HasForeignKey("ApproachOutputsApproachOutputId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessAtomarUnit", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.AtomarUnit", null)
                        .WithMany()
                        .HasForeignKey("AtomarUnitsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessAutomationLevel", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.AutomationLevel", null)
                        .WithMany()
                        .HasForeignKey("AutomationLevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessDirection", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Direction", null)
                        .WithMany()
                        .HasForeignKey("DirectionsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessProcessStrategy", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ProcessStrategy", null)
                        .WithMany()
                        .HasForeignKey("ProcessStrategiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessQuality", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany()
                        .HasForeignKey("QualitiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessQualitySublevel", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany()
                        .HasForeignKey("QualitySublevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessTechnique", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Technique", null)
                        .WithMany()
                        .HasForeignKey("TechniquesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachUsabilityTool", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachUsability", null)
                        .WithMany()
                        .HasForeignKey("ApproachUsabilitiesApproachUsabilityId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Tool", null)
                        .WithMany()
                        .HasForeignKey("ToolsToolId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("DomainArtifactInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.DomainArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("DomainArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ExecutableInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ExecutableInput", null)
                        .WithMany()
                        .HasForeignKey("ExecutableInputsName", "ExecutableInputsLanguage")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ModelArtifactInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ModelArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("ModelArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("QualityScenario", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany()
                        .HasForeignKey("QualitiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Scenario", null)
                        .WithMany()
                        .HasForeignKey("ScenariosScenarioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("QualitySublevelScenario", b =>
                {
                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany()
                        .HasForeignKey("QualitySublevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Scenario", null)
                        .WithMany()
                        .HasForeignKey("ScenariosScenarioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("RefactoringApproachRepresentation", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Representation", null)
                        .WithMany()
                        .HasForeignKey("RepresentationOutputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("RefactoringApproachRuntimeArtifactInput", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RuntimeArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("RuntimeArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachOutput", b =>
                {
                    b.HasOne("Repository.Models.Database.Architecture", "Architecture")
                        .WithMany("ApproachOutputs")
                        .HasForeignKey("ArchitectureName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ServiceType", "ServiceType")
                        .WithMany("ApproachOutputs")
                        .HasForeignKey("ServiceTypeName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Architecture");

                    b.Navigation("ServiceType");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.HasOne("Repository.Models.Database.AccuracyPrecision", "AccuracyPrecision")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("AccuracyPrecisionName")
                        .OnDelete(DeleteBehavior.SetNull)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ResultsQuality", "ResultsQuality")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ResultsQualityName")
                        .OnDelete(DeleteBehavior.SetNull);

                    b.HasOne("Repository.Models.Database.ToolSupport", "ToolSupport")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ToolSupportName")
                        .OnDelete(DeleteBehavior.SetNull);

                    b.HasOne("Repository.Models.Database.ValidationMethod", "ValidationMethod")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ValidationMethodName")
                        .OnDelete(DeleteBehavior.SetNull)
                        .IsRequired();

                    b.Navigation("AccuracyPrecision");

                    b.Navigation("ResultsQuality");

                    b.Navigation("ToolSupport");

                    b.Navigation("ValidationMethod");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesign", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", "ApproachProcess")
                        .WithOne("ArchitecturalDesign")
                        .HasForeignKey("Repository.Models.Database.ArchitecturalDesign", "ApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ArchitecturalDesignSource", "ArchitecturalDesignSource")
                        .WithOne("ArchitecturalDesign")
                        .HasForeignKey("Repository.Models.Database.ArchitecturalDesign", "ArchitecturalDesignSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ApproachProcess");

                    b.Navigation("ArchitecturalDesignSource");
                });

            modelBuilder.Entity("Repository.Models.Database.CalculationMetric", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany("CalculationMetrics")
                        .HasForeignKey("QualityName");

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany("CalculationMetrics")
                        .HasForeignKey("QualitySublevelName");
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany("QualityTradeOffs")
                        .HasForeignKey("QualityName");

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany("QualityTradeOffs")
                        .HasForeignKey("QualitySublevelName");
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", "Quality")
                        .WithMany("QualitySublevels")
                        .HasForeignKey("QualityName");

                    b.Navigation("Quality");
                });

            modelBuilder.Entity("Repository.Models.Database.RefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", "ApproachProcess")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachSource", "ApproachSource")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachUsability", "ApproachUsability")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachUsabilityId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ApproachProcess");

                    b.Navigation("ApproachSource");

                    b.Navigation("ApproachUsability");
                });

            modelBuilder.Entity("Repository.Models.Database.Tool", b =>
                {
                    b.HasOne("Repository.Models.Database.ToolSource", "ToolSource")
                        .WithOne("Tool")
                        .HasForeignKey("Repository.Models.Database.Tool", "ToolSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ToolSource");
                });

            modelBuilder.Entity("ToolToolType", b =>
                {
                    b.HasOne("Repository.Models.Database.ToolType", null)
                        .WithMany()
                        .HasForeignKey("ToolTypesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Tool", null)
                        .WithMany()
                        .HasForeignKey("ToolsToolId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Repository.Models.Database.AccuracyPrecision", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachProcess", b =>
                {
                    b.Navigation("ArchitecturalDesign");

                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachSource", b =>
                {
                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesignSource", b =>
                {
                    b.Navigation("ArchitecturalDesign");
                });

            modelBuilder.Entity("Repository.Models.Database.Architecture", b =>
                {
                    b.Navigation("ApproachOutputs");
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.Navigation("CalculationMetrics");

                    b.Navigation("QualitySublevels");

                    b.Navigation("QualityTradeOffs");
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.Navigation("CalculationMetrics");

                    b.Navigation("QualityTradeOffs");
                });

            modelBuilder.Entity("Repository.Models.Database.ResultsQuality", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ServiceType", b =>
                {
                    b.Navigation("ApproachOutputs");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSource", b =>
                {
                    b.Navigation("Tool");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSupport", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ValidationMethod", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });
#pragma warning restore 612, 618
        }
    }
}
