// <auto-generated />
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Repository.Models;

#nullable disable

namespace Repository.Migrations
{
    [DbContext(typeof(RefactoringApproachContext))]
    [Migration("20230816094202_removeUsabilityFKRequiredV2")]
    partial class removeUsabilityFKRequiredV2
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder.HasAnnotation("ProductVersion", "6.0.1");

            modelBuilder.Entity("AnalysisTypeApproachProcess", b =>
                {
                    b.Property<string>("AnalysisTypesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.HasKey("AnalysisTypesName", "ApproachProcessesApproachProcessId");

                    b.HasIndex("ApproachProcessesApproachProcessId");

                    b.ToTable("JoinTable.Approach.Process.AnalysisType", (string)null);
                });

            modelBuilder.Entity("ApproachOutputRefactoringApproach", b =>
                {
                    b.Property<int>("ApproachOutputsApproachOutputId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachOutputsApproachOutputId", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Output", (string)null);
                });

            modelBuilder.Entity("ApproachProcessAtomarUnit", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("AtomarUnitsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "AtomarUnitsName");

                    b.HasIndex("AtomarUnitsName");

                    b.ToTable("JoinTable.Approach.Process.AtomarUnit", (string)null);
                });

            modelBuilder.Entity("ApproachProcessAutomationLevel", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("AutomationLevelsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "AutomationLevelsName");

                    b.HasIndex("AutomationLevelsName");

                    b.ToTable("JoinTable.Approach.Process.AutomationLevel", (string)null);
                });

            modelBuilder.Entity("ApproachProcessDirection", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("DirectionsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "DirectionsName");

                    b.HasIndex("DirectionsName");

                    b.ToTable("JoinTable.Approach.Process.Direction", (string)null);
                });

            modelBuilder.Entity("ApproachProcessProcessStrategy", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ProcessStrategiesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "ProcessStrategiesName");

                    b.HasIndex("ProcessStrategiesName");

                    b.ToTable("JoinTable.Approach.Process.Strategy", (string)null);
                });

            modelBuilder.Entity("ApproachProcessQuality", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("QualitiesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "QualitiesName");

                    b.HasIndex("QualitiesName");

                    b.ToTable("JoinTable.Approach.Process.Quality", (string)null);
                });

            modelBuilder.Entity("ApproachProcessQualitySublevel", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("QualitySublevelsName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "QualitySublevelsName");

                    b.HasIndex("QualitySublevelsName");

                    b.ToTable("JoinTable.Approach.Process.QualitySublevel", (string)null);
                });

            modelBuilder.Entity("ApproachProcessTechnique", b =>
                {
                    b.Property<int>("ApproachProcessesApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("TechniquesName")
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachProcessesApproachProcessId", "TechniquesName");

                    b.HasIndex("TechniquesName");

                    b.ToTable("JoinTable.Approach.Process.Technique", (string)null);
                });

            modelBuilder.Entity("DomainArtifactInputRefactoringApproach", b =>
                {
                    b.Property<string>("DomainArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("DomainArtifactInputsName", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Input.DomainArtifact", (string)null);
                });

            modelBuilder.Entity("ExecutableInputRefactoringApproach", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("ExecutableInputsName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ExecutableInputsLanguage")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "ExecutableInputsName", "ExecutableInputsLanguage");

                    b.HasIndex("ExecutableInputsName", "ExecutableInputsLanguage");

                    b.ToTable("JoinTable.Approach.Input.Executable", (string)null);
                });

            modelBuilder.Entity("ModelArtifactInputRefactoringApproach", b =>
                {
                    b.Property<string>("ModelArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ModelArtifactInputsName", "RefactoringApproachesRefactoringApproachId");

                    b.HasIndex("RefactoringApproachesRefactoringApproachId");

                    b.ToTable("JoinTable.Approach.Input.ModelArtifact", (string)null);
                });

            modelBuilder.Entity("QualityScenario", b =>
                {
                    b.Property<string>("QualitiesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ScenariosScenarioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("QualitiesName", "ScenariosScenarioId");

                    b.HasIndex("ScenariosScenarioId");

                    b.ToTable("QualityScenario");
                });

            modelBuilder.Entity("QualitySublevelScenario", b =>
                {
                    b.Property<string>("QualitySublevelsName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ScenariosScenarioId")
                        .HasColumnType("INTEGER");

                    b.HasKey("QualitySublevelsName", "ScenariosScenarioId");

                    b.HasIndex("ScenariosScenarioId");

                    b.ToTable("QualitySublevelScenario");
                });

            modelBuilder.Entity("RefactoringApproachRepresentation", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("RepresentationOutputsName")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "RepresentationOutputsName");

                    b.HasIndex("RepresentationOutputsName");

                    b.ToTable("JoinTable.Approach.Output.Representation", (string)null);
                });

            modelBuilder.Entity("RefactoringApproachRuntimeArtifactInput", b =>
                {
                    b.Property<int>("RefactoringApproachesRefactoringApproachId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("RuntimeArtifactInputsName")
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachesRefactoringApproachId", "RuntimeArtifactInputsName");

                    b.HasIndex("RuntimeArtifactInputsName");

                    b.ToTable("JoinTable.Approach.Input.RuntimeArtifact", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.AccuracyPrecision", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.AccuracyPrecision", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "High",
                            Description = "Estimates the accuracy/precision of the service identification approach as high."
                        },
                        new
                        {
                            Name = "Medium",
                            Description = "Estimates the accuracy/precision of the service identification approach as medium."
                        },
                        new
                        {
                            Name = "Low",
                            Description = "Estimates the accuracy/precision of the service identification approach as low."
                        },
                        new
                        {
                            Name = "Not available",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AnalysisType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AnalysisType", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Static",
                            Description = "Static analysis is performed without executing a software system. Dependencies between classes are potential relationships, like method calls and access attributes. These dependencies are analyzed to identify strongly connected classes, for example, to identify services."
                        },
                        new
                        {
                            Name = "Dynamic",
                            Description = "Dynamic analysis is performed by examining the software system at run time. Dependencies between software elements (e.g., class instantiations and accesses, function calls, relationships between database tables, etc.) are collected during the program execution. The execution is performed based on a set of cases that covers the system functionalities, called execution scenarios"
                        },
                        new
                        {
                            Name = "Lexical",
                            Description = "Lexical analysis techniques suppose that the similarity between the classes should be taken into account during service identification process. This analysis plays the main role in approaches that used features location and textual similarity techniques."
                        },
                        new
                        {
                            Name = "Historic",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachOutput", b =>
                {
                    b.Property<int>("ApproachOutputId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("ArchitectureName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("ServiceTypeName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachOutputId");

                    b.HasIndex("ArchitectureName");

                    b.HasIndex("ServiceTypeName");

                    b.ToTable("Approach.Output");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachProcess", b =>
                {
                    b.Property<int>("ApproachProcessId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachProcessId");

                    b.ToTable("Approach.Process");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachSource", b =>
                {
                    b.Property<int>("ApproachSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Authors")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Link")
                        .HasColumnType("TEXT");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<int>("Year")
                        .HasColumnType("INTEGER");

                    b.HasKey("ApproachSourceId");

                    b.ToTable("Approach.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.Property<int>("ApproachUsabilityId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("AccuracyPrecisionName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("ResultsQualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ToolSupportName")
                        .HasColumnType("TEXT");

                    b.Property<string>("ValidationMethodName")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ApproachUsabilityId");

                    b.HasIndex("AccuracyPrecisionName");

                    b.HasIndex("ResultsQualityName");

                    b.HasIndex("ToolSupportName");

                    b.HasIndex("ValidationMethodName");

                    b.ToTable("Approach.Usability");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesign", b =>
                {
                    b.Property<int>("ArchitecturalDesignId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ArchitecturalDesignSourceId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("Category")
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ArchitecturalDesignId");

                    b.HasIndex("ApproachProcessId")
                        .IsUnique();

                    b.HasIndex("ArchitecturalDesignSourceId")
                        .IsUnique();

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.ToTable("ArchitecturalDesign");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesignSource", b =>
                {
                    b.Property<int>("ArchitecturalDesignSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Links")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Source")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ArchitecturalDesignSourceId");

                    b.ToTable("ArchitecturalDesign.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.Architecture", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.Architecture", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Services",
                            Description = ""
                        },
                        new
                        {
                            Name = "Microservices",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AtomarUnit", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AtomarUnit", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Function",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Functionality",
                            Description = "A meta-heuristic for solving optimization problems that is based on \"natural selection\". It relies on the calculation of a fitness function to reach an optimal (or near-optimal) solution. By definition, an optimal solution is a feasible solution where the fitness function reaches its maximum (or minimum) value."
                        },
                        new
                        {
                            Name = "Business Capability",
                            Description = "Clustering consists of classifying and partitioning data into clusters that share common properties. These clusters are built based on the internal homogeneity of their elements and the external separation between them."
                        },
                        new
                        {
                            Name = "Entity",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        },
                        new
                        {
                            Name = "Interface",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        },
                        new
                        {
                            Name = "Other",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.AutomationLevel", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.AutomationLevel", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Automatic",
                            Description = "Automatic approaches do not need any human intervention during the identification process."
                        },
                        new
                        {
                            Name = "Semi-automatic",
                            Description = "Semi-automatic approaches need human experts to perform some of the tasks."
                        },
                        new
                        {
                            Name = "Manual",
                            Description = "Manual approaches depend entirely on human experts."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.CalculationMetric", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualitySublevelName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.HasIndex("QualitySublevelName");

                    b.ToTable("Approach.Process.CalculationMetric");
                });

            modelBuilder.Entity("Repository.Models.Database.Direction", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Direction", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Bottom-up",
                            Description = "A bottom-up process starts with low-level artifacts to maximize code reuse and minimize changes."
                        },
                        new
                        {
                            Name = "Top-down",
                            Description = "A top-down process starts with high-level artifacts, e.g., domain analysis or requirement characterization of systems to define their functionalities."
                        },
                        new
                        {
                            Name = "Mixed",
                            Description = "A mixed hybrid process combines a top-down and a bottom-up process. It uses both requirements and implementation artifacts to identify the candidate services."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.DomainArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.DomainArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Ontology",
                            Description = "An ontology is a structured set of terms representing the semantics of a domain, whether through metadata or elements of a knowledge domain"
                        },
                        new
                        {
                            Name = "Human expertise",
                            Description = ""
                        },
                        new
                        {
                            Name = "Documentation",
                            Description = "Software documentation describes and documents systems at different levels of abstraction. It includes textual descriptions as well as diagrams and models"
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ExecutableInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Language")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name", "Language");

                    b.ToTable("Approach.Input.Executable", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Source code",
                            Language = "No specification",
                            Description = ""
                        },
                        new
                        {
                            Name = "Database file",
                            Language = "No specification",
                            Description = ""
                        },
                        new
                        {
                            Name = "Test cases",
                            Language = "No specification",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ModelArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.ModelArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Business process model",
                            Description = "Business Process Models (BPMs) describe sets of activities and tasks that accomplish an organizational goal"
                        },
                        new
                        {
                            Name = "Use case model",
                            Description = "Use case diagrams are behavioral diagrams and visualize the externally visible interaction of actors with the system under development. The diagram consists of the system, associated use cases and actors and relates them to each other."
                        },
                        new
                        {
                            Name = "Activity diagram",
                            Description = "Activity diagrams visually presents a series of actions or flow of control in a system."
                        },
                        new
                        {
                            Name = "Data flow diagram",
                            Description = "Data Flow Diagrams (DFDs) are graphical representations of functional dependencies, based on the analysis of data flows, between business functions or processes"
                        },
                        new
                        {
                            Name = "State machine diagram",
                            Description = "State Machine Diagrams (SMDs) shows a dynamic view of a system and describe the different states that entities can have during their lifetimes"
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ProcessStrategy", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Strategy", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Greenfield",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Rewrite / Rebuild",
                            Description = "A meta-heuristic for solving optimization problems that is based on \"natural selection\". It relies on the calculation of a fitness function to reach an optimal (or near-optimal) solution. By definition, an optimal solution is a feasible solution where the fitness function reaches its maximum (or minimum) value."
                        },
                        new
                        {
                            Name = "Refactor",
                            Description = "Clustering consists of classifying and partitioning data into clusters that share common properties. These clusters are built based on the internal homogeneity of their elements and the external separation between them."
                        },
                        new
                        {
                            Name = "Strangler",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        },
                        new
                        {
                            Name = "Continuous Evolution",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        },
                        new
                        {
                            Name = "Extension",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Category")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualitySublevelName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.HasIndex("QualitySublevelName");

                    b.ToTable("Approach.Process.Quality", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Reliability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Compatibility",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Security",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Performance",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Scalability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Portability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Independence",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Maintainability",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Business",
                            Category = "Attribute",
                            Description = ""
                        },
                        new
                        {
                            Name = "Cohesion",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Coupling",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Granularity",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Isolation",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Autonomy",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Technology Heterogeneity",
                            Category = "SystemProperty",
                            Description = ""
                        },
                        new
                        {
                            Name = "Complexity",
                            Category = "SystemProperty",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("QualityName")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.HasIndex("QualityName");

                    b.ToTable("Approach.Process.QualitySublevel", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Availability",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Fault Tolerance",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Recoverability",
                            QualityName = "Reliability"
                        },
                        new
                        {
                            Name = "Interoperability",
                            QualityName = "Compatibility"
                        },
                        new
                        {
                            Name = "Co-Existence",
                            QualityName = "Compatibility"
                        },
                        new
                        {
                            Name = "Confidentiality",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Accountability",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Authenticity",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Integrity",
                            QualityName = "Security"
                        },
                        new
                        {
                            Name = "Time Behavior",
                            QualityName = "Performance"
                        },
                        new
                        {
                            Name = "Resource Utilization",
                            QualityName = "Performance"
                        },
                        new
                        {
                            Name = "Installability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Adaptability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Replaceability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Deployability",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Agility",
                            QualityName = "Portability"
                        },
                        new
                        {
                            Name = "Modifiability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Modularity",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Reusability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Testability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Analysability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Monitorability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Manageability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Understandability",
                            QualityName = "Maintainability"
                        },
                        new
                        {
                            Name = "Execution Cost",
                            QualityName = "Business"
                        },
                        new
                        {
                            Name = "Organizational Alignment",
                            QualityName = "Business"
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.RefactoringApproach", b =>
                {
                    b.Property<int>("RefactoringApproachId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachProcessId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachSourceId")
                        .HasColumnType("INTEGER");

                    b.Property<int>("ApproachUsabilityId")
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("RefactoringApproachId");

                    b.HasIndex("ApproachProcessId")
                        .IsUnique();

                    b.HasIndex("ApproachSourceId")
                        .IsUnique();

                    b.HasIndex("ApproachUsabilityId")
                        .IsUnique();

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.ToTable("Approaches");
                });

            modelBuilder.Entity("Repository.Models.Database.Representation", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.Representation", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Source code",
                            Description = "An ontology is a structured set of terms representing the semantics of a domain, whether through metadata or elements of a knowledge domain"
                        },
                        new
                        {
                            Name = "List of services",
                            Description = ""
                        },
                        new
                        {
                            Name = "Splitting recommendations",
                            Description = "Software documentation describes and documents systems at different levels of abstraction. It includes textual descriptions as well as diagrams and models"
                        },
                        new
                        {
                            Name = "Guideline / Workflow",
                            Description = "Software documentation describes and documents systems at different levels of abstraction. It includes textual descriptions as well as diagrams and models"
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ResultsQuality", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ResultsQuality", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "High",
                            Description = "Estimates the quality of the identified candidate service(s) as high."
                        },
                        new
                        {
                            Name = "Medium",
                            Description = "Estimates the quality of the identified candidate service(s) as medium."
                        },
                        new
                        {
                            Name = "Low",
                            Description = "Estimates the quality of the identified candidate service(s) as low."
                        },
                        new
                        {
                            Name = "Not available",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.RuntimeArtifactInput", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Input.RuntimeArtifact", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Log traces",
                            Description = "Execution traces of legacy software systems depicting the dynamic behavior of the systems"
                        },
                        new
                        {
                            Name = "User-Application interactions",
                            Description = "User-interface inputs capturing the relationship between users and the system’s functionalities."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Scenario", b =>
                {
                    b.Property<int>("ScenarioId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.Property<string>("Difficulty")
                        .HasColumnType("TEXT");

                    b.Property<string>("Importance")
                        .HasColumnType("TEXT");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ScenarioId");

                    b.ToTable(".Scenario", (string)null);
                });

            modelBuilder.Entity("Repository.Models.Database.ServiceType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Output.ServiceType", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Business services",
                            Description = "Business services correspond to business processes or use cases and are services used by users. Examples of business services include flight booking services."
                        },
                        new
                        {
                            Name = "Enterprise services",
                            Description = "Enterprise services are of finer granularity than business services. They implement generic business functionalities that can be reused across different applications. Examples of enterprise services include \"online payment\" and \"tax calculation\"."
                        },
                        new
                        {
                            Name = "Application services",
                            Description = "Application services provide functionalities specific to one application. They exist to support reuse within one application. Examples of application-task services include quoting requests."
                        },
                        new
                        {
                            Name = "Entity services",
                            Description = "Entity services provide access to and the management of the persistent data of legacy software systems. They support actions on data (CRUD) and may have side-effects like modification of shared data. Examples of entity services include management services for clients, and bank accounts."
                        },
                        new
                        {
                            Name = "Utility services",
                            Description = "Utility services do not directly support business services but provide some cross-cutting functionalities required by domain-specific services. Examples of typical utility services include notification, logging, and authentication."
                        },
                        new
                        {
                            Name = "Infrastructure services",
                            Description = "Infrastructure services allow users to deploy and run service oriented architecture systems. They include services for communication routing, protocol conversion, message processing and transformation. Examples of infrastructure services include publish–subscribe, message queues, and enterprise service buses (ESBs)."
                        },
                        new
                        {
                            Name = "No specification",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Technique", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Process.Technique", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Wrapping / Black Box",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Genetic algorithm",
                            Description = "A meta-heuristic for solving optimization problems that is based on \"natural selection\". It relies on the calculation of a fitness function to reach an optimal (or near-optimal) solution. By definition, an optimal solution is a feasible solution where the fitness function reaches its maximum (or minimum) value."
                        },
                        new
                        {
                            Name = "Clustering",
                            Description = "Clustering consists of classifying and partitioning data into clusters that share common properties. These clusters are built based on the internal homogeneity of their elements and the external separation between them."
                        },
                        new
                        {
                            Name = "Custom heuristics",
                            Description = "Custom heuristic algorithms to decompose legacy software into Service Oriented Architecture differing from predefined algorithms."
                        },
                        new
                        {
                            Name = "General guidelines",
                            Description = "Proposes best practices, lessons learned, or recommendations for service identification."
                        },
                        new
                        {
                            Name = "Domain-Driven Design",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Data-flow driven",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Graph-based",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Scenario analysis",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Execution-trace modeling",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        },
                        new
                        {
                            Name = "Performance modeling",
                            Description = "A black-box identification technique that encapsulates the legacy system with a service layer without changing its implementation. The wrapper provides access to the legacy system through a service encapsulation layer that exposes only the functionalities desired by the software architect."
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.Tool", b =>
                {
                    b.Property<int>("ToolId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Identifier")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.Property<int>("ToolSourceId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ToolId");

                    b.HasIndex("Identifier")
                        .IsUnique();

                    b.HasIndex("ToolSourceId")
                        .IsUnique();

                    b.ToTable("Tools");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSource", b =>
                {
                    b.Property<int>("ToolSourceId")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("INTEGER");

                    b.Property<string>("Link")
                        .HasColumnType("TEXT");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("TEXT");

                    b.HasKey("ToolSourceId");

                    b.ToTable("Tool.Source");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSupport", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ToolSupport", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Industry ready",
                            Description = "The approach has a tool implementation which is industry ready."
                        },
                        new
                        {
                            Name = "Open source",
                            Description = "The approach has a tool implementation which is open source."
                        },
                        new
                        {
                            Name = "Prototype",
                            Description = "The approach has a prototype tool which was implementation."
                        },
                        new
                        {
                            Name = "No tool support",
                            Description = ""
                        });
                });

            modelBuilder.Entity("Repository.Models.Database.ToolType", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Tool.Type");
                });

            modelBuilder.Entity("Repository.Models.Database.ValidationMethod", b =>
                {
                    b.Property<string>("Name")
                        .HasColumnType("TEXT");

                    b.Property<string>("Description")
                        .HasColumnType("TEXT");

                    b.HasKey("Name");

                    b.ToTable("Approach.Usability.ValidationMethod", (string)null);

                    b.HasData(
                        new
                        {
                            Name = "Experiment",
                            Description = "The approach was applied to and tested on a (small) experimental system."
                        },
                        new
                        {
                            Name = "Industry",
                            Description = "The approach was applied to and tested on a real industrial system."
                        },
                        new
                        {
                            Name = "Case study",
                            Description = ""
                        },
                        new
                        {
                            Name = "No validation",
                            Description = ""
                        });
                });

            modelBuilder.Entity("ToolToolType", b =>
                {
                    b.Property<string>("ToolTypesName")
                        .HasColumnType("TEXT");

                    b.Property<int>("ToolsToolId")
                        .HasColumnType("INTEGER");

                    b.HasKey("ToolTypesName", "ToolsToolId");

                    b.HasIndex("ToolsToolId");

                    b.ToTable("JoinTable.Tool.Type", (string)null);
                });

            modelBuilder.Entity("AnalysisTypeApproachProcess", b =>
                {
                    b.HasOne("Repository.Models.Database.AnalysisType", null)
                        .WithMany()
                        .HasForeignKey("AnalysisTypesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachOutputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachOutput", null)
                        .WithMany()
                        .HasForeignKey("ApproachOutputsApproachOutputId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessAtomarUnit", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.AtomarUnit", null)
                        .WithMany()
                        .HasForeignKey("AtomarUnitsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessAutomationLevel", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.AutomationLevel", null)
                        .WithMany()
                        .HasForeignKey("AutomationLevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessDirection", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Direction", null)
                        .WithMany()
                        .HasForeignKey("DirectionsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessProcessStrategy", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ProcessStrategy", null)
                        .WithMany()
                        .HasForeignKey("ProcessStrategiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessQuality", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany()
                        .HasForeignKey("QualitiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessQualitySublevel", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany()
                        .HasForeignKey("QualitySublevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ApproachProcessTechnique", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", null)
                        .WithMany()
                        .HasForeignKey("ApproachProcessesApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Technique", null)
                        .WithMany()
                        .HasForeignKey("TechniquesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("DomainArtifactInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.DomainArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("DomainArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ExecutableInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ExecutableInput", null)
                        .WithMany()
                        .HasForeignKey("ExecutableInputsName", "ExecutableInputsLanguage")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("ModelArtifactInputRefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ModelArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("ModelArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("QualityScenario", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany()
                        .HasForeignKey("QualitiesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Scenario", null)
                        .WithMany()
                        .HasForeignKey("ScenariosScenarioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("QualitySublevelScenario", b =>
                {
                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany()
                        .HasForeignKey("QualitySublevelsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Scenario", null)
                        .WithMany()
                        .HasForeignKey("ScenariosScenarioId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("RefactoringApproachRepresentation", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Representation", null)
                        .WithMany()
                        .HasForeignKey("RepresentationOutputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("RefactoringApproachRuntimeArtifactInput", b =>
                {
                    b.HasOne("Repository.Models.Database.RefactoringApproach", null)
                        .WithMany()
                        .HasForeignKey("RefactoringApproachesRefactoringApproachId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.RuntimeArtifactInput", null)
                        .WithMany()
                        .HasForeignKey("RuntimeArtifactInputsName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachOutput", b =>
                {
                    b.HasOne("Repository.Models.Database.Architecture", "Architecture")
                        .WithMany("ApproachOutputs")
                        .HasForeignKey("ArchitectureName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ServiceType", "ServiceType")
                        .WithMany("ApproachOutputs")
                        .HasForeignKey("ServiceTypeName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Architecture");

                    b.Navigation("ServiceType");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.HasOne("Repository.Models.Database.AccuracyPrecision", "AccuracyPrecision")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("AccuracyPrecisionName")
                        .OnDelete(DeleteBehavior.SetNull)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ResultsQuality", "ResultsQuality")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ResultsQualityName")
                        .OnDelete(DeleteBehavior.SetNull);

                    b.HasOne("Repository.Models.Database.ToolSupport", "ToolSupport")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ToolSupportName")
                        .OnDelete(DeleteBehavior.SetNull);

                    b.HasOne("Repository.Models.Database.ValidationMethod", "ValidationMethod")
                        .WithMany("ApproachUsabilities")
                        .HasForeignKey("ValidationMethodName")
                        .OnDelete(DeleteBehavior.SetNull)
                        .IsRequired();

                    b.Navigation("AccuracyPrecision");

                    b.Navigation("ResultsQuality");

                    b.Navigation("ToolSupport");

                    b.Navigation("ValidationMethod");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesign", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", "ApproachProcess")
                        .WithOne("ArchitecturalDesign")
                        .HasForeignKey("Repository.Models.Database.ArchitecturalDesign", "ApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ArchitecturalDesignSource", "ArchitecturalDesignSource")
                        .WithOne("ArchitecturalDesign")
                        .HasForeignKey("Repository.Models.Database.ArchitecturalDesign", "ArchitecturalDesignSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ApproachProcess");

                    b.Navigation("ArchitecturalDesignSource");
                });

            modelBuilder.Entity("Repository.Models.Database.CalculationMetric", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany("CalculationMetrics")
                        .HasForeignKey("QualityName");

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany("CalculationMetrics")
                        .HasForeignKey("QualitySublevelName");
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", null)
                        .WithMany("QualityTradeOffs")
                        .HasForeignKey("QualityName");

                    b.HasOne("Repository.Models.Database.QualitySublevel", null)
                        .WithMany("QualityTradeOffs")
                        .HasForeignKey("QualitySublevelName");
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.HasOne("Repository.Models.Database.Quality", "Quality")
                        .WithMany("QualitySublevels")
                        .HasForeignKey("QualityName");

                    b.Navigation("Quality");
                });

            modelBuilder.Entity("Repository.Models.Database.RefactoringApproach", b =>
                {
                    b.HasOne("Repository.Models.Database.ApproachProcess", "ApproachProcess")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachProcessId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachSource", "ApproachSource")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.ApproachUsability", "ApproachUsability")
                        .WithOne("RefactoringApproach")
                        .HasForeignKey("Repository.Models.Database.RefactoringApproach", "ApproachUsabilityId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ApproachProcess");

                    b.Navigation("ApproachSource");

                    b.Navigation("ApproachUsability");
                });

            modelBuilder.Entity("Repository.Models.Database.Tool", b =>
                {
                    b.HasOne("Repository.Models.Database.ToolSource", "ToolSource")
                        .WithOne("Tool")
                        .HasForeignKey("Repository.Models.Database.Tool", "ToolSourceId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("ToolSource");
                });

            modelBuilder.Entity("ToolToolType", b =>
                {
                    b.HasOne("Repository.Models.Database.ToolType", null)
                        .WithMany()
                        .HasForeignKey("ToolTypesName")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("Repository.Models.Database.Tool", null)
                        .WithMany()
                        .HasForeignKey("ToolsToolId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Repository.Models.Database.AccuracyPrecision", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachProcess", b =>
                {
                    b.Navigation("ArchitecturalDesign");

                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachSource", b =>
                {
                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ApproachUsability", b =>
                {
                    b.Navigation("RefactoringApproach");
                });

            modelBuilder.Entity("Repository.Models.Database.ArchitecturalDesignSource", b =>
                {
                    b.Navigation("ArchitecturalDesign");
                });

            modelBuilder.Entity("Repository.Models.Database.Architecture", b =>
                {
                    b.Navigation("ApproachOutputs");
                });

            modelBuilder.Entity("Repository.Models.Database.Quality", b =>
                {
                    b.Navigation("CalculationMetrics");

                    b.Navigation("QualitySublevels");

                    b.Navigation("QualityTradeOffs");
                });

            modelBuilder.Entity("Repository.Models.Database.QualitySublevel", b =>
                {
                    b.Navigation("CalculationMetrics");

                    b.Navigation("QualityTradeOffs");
                });

            modelBuilder.Entity("Repository.Models.Database.ResultsQuality", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ServiceType", b =>
                {
                    b.Navigation("ApproachOutputs");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSource", b =>
                {
                    b.Navigation("Tool");
                });

            modelBuilder.Entity("Repository.Models.Database.ToolSupport", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });

            modelBuilder.Entity("Repository.Models.Database.ValidationMethod", b =>
                {
                    b.Navigation("ApproachUsabilities");
                });
#pragma warning restore 612, 618
        }
    }
}
